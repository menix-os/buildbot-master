# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import *
import os
import user_config

c = BuildmasterConfig = {}

current_dir = os.path.dirname(os.path.abspath(__file__))
secrets_dir = os.path.join(current_dir, user_config.secrets_dir)
jinx_path = f"../source/{user_config.jinx_path}"

c["secretsProviders"] = [secrets.SecretInAFile(dirname=secrets_dir, strip=True)]

c["title"] = user_config.title
c["titleURL"] = user_config.title_url
c["buildbotURL"] = user_config.bot_url
c["services"] = []
c["www"] = dict(
    port=user_config.www_port,
    plugins=dict(
        waterfall_view={},
        console_view={},
        grid_view={},
    ),
)
c["db"] = {"db_url": user_config.db_url}
c["protocols"] = {"pb": {"port": user_config.bot_port}}
c["workers"] = []
c["schedulers"] = []
c["builders"] = []
c["change_source"] = []

c["change_source"].append(
    changes.GitPoller(
        user_config.repo_url,
        name="poll_bootstrap",
        workdir="gitpoller-workdir",
        branch=user_config.repo_branch,
        pollInterval=user_config.update_secs,
    )
)


@util.renderer
def jinx_build(props, arch):
    ret = []
    pkgs = str(props.getProperty("pkgs_unbuilt")).split(" ")

    for p in pkgs:
        # Check if package exists already on the master.
        if "host:" in p:
            ret.append(
                util.ShellArg(
                    command=[jinx_path, "host-build", p.split("host:")[1]],
                    logname=p,
                    haltOnFailure=True,
                )
            )
        else:
            ret.append(
                util.ShellArg(
                    command=[jinx_path, "build", p],
                    logname=p,
                    haltOnFailure=True,
                )
            )
    return ret


def path_not_exists(step):
    return not os.path.exists("")


def get_pkgs_unbuilt(rc, stdout: str, stderr: str):
    lines = stdout.splitlines()
    if len(lines) != 0:
        return {"pkgs_unbuilt": lines[-1].strip()}
    else:
        return {"pkgs_unbuilt": ""}


def find_compatible_worker_names(archs):
    ret = []
    for w in user_config.workers:
        if archs["name"] in w["archs"]:
            ret.append(w)
    return ret


def create_target(c, arch):
    arch_name = arch["name"]
    scheduler_name = f"scheduler-{arch_name}"
    builder_name = f"build-{arch_name}"

    # If there's at least one compatible worker, add the builder for it.
    worker_names = find_compatible_worker_names(arch)
    if len(worker_names) == 0:
        return

    c["schedulers"].append(
        schedulers.SingleBranchScheduler(
            name=scheduler_name,
            change_filter=util.ChangeFilter(branch=user_config.repo_branch),
            treeStableTimer=None,
            builderNames=[builder_name],
        )
    )

    # Scheduler for force rebuilds
    c["schedulers"].append(
        schedulers.ForceScheduler(
            name=f"force-{scheduler_name}",
            builderNames=[builder_name],
            buttonName=f"Force rebuild {builder_name}",
        )
    )

    f = util.BuildFactory()

    f.addStep(
        steps.Git(
            name="checkout_distro",
            description="Checking out distro sources",
            repourl=user_config.repo_url,
            branch=user_config.repo_branch,
            submodules=True,
            mode="incremental",
            workdir="source",
            logEnviron=False,
        )
    )
    f.addStep(
        steps.SetPropertyFromCommand(
            name="check_build_dir",
            command="if [ -f .jinx-parameters ]; then echo 1; else echo 0; fi",
            property="build_dir_exists",
            workdir="build",
            logEnviron=False,
        )
    )
    f.addStep(
        steps.ShellCommand(
            name="prepare_dir",
            description="Prepare build directory",
            command=[jinx_path, "init", "../source", f"ARCH={arch_name}"],
            workdir="build",
            logEnviron=False,
            doStepIf=lambda step: step.getProperty("build_dir_exists") == "0",
        )
    )
    f.addStep(
        steps.SetPropertyFromCommand(
            name="find_unbuilt",
            description="Find unbuilt packages",
            command=[jinx_path, "dry-run", "*"],
            extract_fn=get_pkgs_unbuilt,
            workdir="build",
            logEnviron=False,
            haltOnFailure=True,
        )
    )
    f.addStep(
        steps.ShellSequence(
            name="build_pkgs",
            description="Build packages",
            commands=jinx_build.withArgs(arch),
            workdir=f"build",
            logEnviron=False,
            haltOnFailure=True,
        )
    )
    f.addStep(
        steps.DirectoryUpload(
            name="upload_pkgs",
            workersrc="pkgs",
            masterdest=arch["results"],
        )
    )

    c["builders"].append(
        util.BuilderConfig(
            name=builder_name,
            workernames=list(map(lambda x: x["name"], worker_names)),
            factory=f,
        )
    )


c["www"]["authz"] = util.Authz(
    allowRules=[util.AnyControlEndpointMatcher(role="admin")],
    roleMatchers=[
        util.RolesFromUsername(
            roles=["admin"], usernames=list(user_config.admins)
        )
    ],
)
c["www"]["auth"] = util.UserPasswordAuth(user_config.admins)

for w in user_config.workers:
    c["workers"].append(
        worker.Worker(
            w["name"],
            util.Secret(w["name"]),
            max_builds=w["max_builds"],
            properties={},
            defaultProperties={},
        )
    )

for a in user_config.archs:
    create_target(c, a)
